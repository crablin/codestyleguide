# 領域導向設計

## 分層設計

- 應用程式層 (Application Layer)
  - Website / Web API
  - Console
  - WinForm
- 領域模型層 (Domain Model Layer)
  - Domain
- 基礎架構層 (Infrastruct Layer)
  - Repository 

Reference: [MSDN 設計 DDD 導向微服務](https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice)

為何DDD要如此分層，主要是因為當我們要寫測試程式時，我們可以依層級去測試。 

最主要的當然就是領域模型層的測試，每階層透過 interface 的取用，就可以確立每個層級的程式運作。

## 貧血 / 充血 領域模型

這個名詞是在2003年，`Martin Fowler`發明此專有名詞，主要是說明依模組開發時，模組本身的撰寫方式及性質。

### 貧血領域模型 Anemic Domain Model

- 未實作建構式或建構式無帶入任何參數
- 無任何邏輯及處理資料的程式碼在模組內
- 目前 Table Model, Dto 等同該模型定義

### 充血領域模型 Rich Domain Model

- 建構式的參數包含此模組處理時需要的所有初始資訊，例如：
    * 發票字軌模組：帶入發票主檔、字軌設定清單、開立發票日期
- `Method` 執行函式，會改變此模組內的資料，例如：
    * 新增字軌： AppendConfig(data)，將第三方取回的新字軌，新增到字軌設定清單內
    * 產生發票號碼： ApplyReceiptNumber()，依模組內的開立發票日期及字軌設定，發出一組發票號
- `Property` 模組欄位，可用於內部資料、清單運算的結果，例如：
    * 剩餘的發票數量：RemainingAmount => Tracks.Sum(t => t.RemainingCount)，取得內部資料的運算結果

使用充血模型是**DDD**設計上必要的做法，因為他將領域邏輯的運作皆放在模組內，可達到高內聚低耦合的優點。
- 高內聚：所有的邏輯動作皆包含在一個模組內
- 低耦合：模組內的 `Method` 僅修改自身內部的資料，不會與其他物件有任何相依性

### 優缺點

| | 充血模型 | 貧血模型 | 
| --- | --- | --- | 
| 優點 | 高內聚低耦合，邏輯集中於單一模組<br />讓測試變的簡單，也容易理解資料的新增及變更。| 資料交付給函式運作的方式，對於一般工程師的思考邏輯較容易開發<br />容易看出資料走向，容易上手。| 
| 缺點 | 需要熟悉業務邏輯，又需要熟悉開發模組時的切分及限制，學習成本及設定成本都不低，難以上手。 |當大型流程開發時，資料從前端拋轉到寫入資料庫，容易會有不知資料在何處被修改的問題，造成查錯困難高。<br />同時因為是資料流開發的方式，邏輯易分散於各個不同的Layer，造成後續維護的人的困擾。| 

### 領域模型聚合設計 Aggregate Root x Entity

- **根領域模型(Aggregate Root)**：當`根`領域模型代表物件內，該模組內有其他相關的領域模型。
- **子領域模型(Entity)**：`子`領域模型的存在是因為`根`模型的邏輯太過繁多，而將同一類型的邏輯切分為另一個領域模型，方便分離測試及邏輯確認。

實作上，根領域模型為我們常用的 Factory 工廠模式產生的 Entity；子領域模型為根領域模型內的 Entity。

### 領域模型 x 相依注入

關於領域模型是否可使用相依注入取得第三方或寫入資料庫的資料，是很多架構專家都很苦惱的問題，因為模型內有包含了許多邏輯，邏輯流程有時需要其他資料的判斷，若能直接存取資料庫將可以減少很多程式碼拋接的問題，又可以把邏輯一致的放在領域模型中。

基於下述的兩個條件
* 充血模型，已準備了此模組運作時所需所有資料
* 模組內的 `Method`，僅能修改自身內部的資料

及撰寫程式的考量下，是否使用的定義如下：

**不允許** 領域模型(Entity)內使用資料庫或第三方的存取，但是除了根模型。因為讀取資料違反充血模型的定義，同時增加領域模型的複雜度。

**允許** 根領域模型(Aggregate Root)使用資料庫或第三方的存取，根模型等同 Process 的延續，內部包含了不同類型的運作邏輯，在此模型可以使用，可以達到邏輯的聚合，也可以協助


